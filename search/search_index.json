{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Hola ayudaaaaaaaaaaaaaaaa</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Examen_1/","title":"Examen 1","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Examen_1/#simon-dice","title":"Sim\u00f3n Dice","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> </li> <li> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> </li> <li> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> </li> </ul> <p>Reglas del juego (obligatorias)</p> <ul> <li> <p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> </li> <li> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> </li> <li> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> </li> <li> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> </li> <li> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> </li> <li> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p> </li> </ul>"},{"location":"Sistemas_Embebidos_I/Corte_I/Examen_1/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p>Esquem\u00e1tico del circuito usado durante el reto.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Examen_1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include &lt;stdlib.h&gt;  //Para la funcion de rand y srand\n#include \"pico/time.h\"// Para utilizar el tiempo\n\n //DEFINIR LOS LEDS Y LOS BOTONES\n#define LED_RO 0\n#define LED_AZ 1\n#define LED_VE 2\n#define LED_AM 3\n\n#define Boton_RO 21\n#define Boton_AZ 20\n#define Boton_VE 19\n#define Boton_AM 18\n\nint Rondas = 15; //N\u00famero de rondas\nint Secuencia[15];//Tama\u00f1o del array para guardar la secuencia\n\nint leer_boton() {     //Funcion para leer el boton\n    while (true) {\n        if (gpio_get(Boton_RO)) {\n              while (gpio_get(Boton_RO)){ sleep_ms(10); // Para evitar rebotes se espera y se devuelve el valor del led\n              return LED_RO;\n            }\n        }\n        if (gpio_get(Boton_AZ)) {\n              while (gpio_get(Boton_AZ)){ sleep_ms(10);\n              return LED_AZ;\n            }\n        }\n        if (gpio_get(Boton_VE)) {\n              while (gpio_get(Boton_VE)){ sleep_ms(10);\n              return LED_VE;\n            }\n        }\n        if (gpio_get(Boton_AM)) {\n              while (gpio_get(Boton_AM)){ sleep_ms(10);\n              return LED_AM;\n            }\n        }\n    }\n}\n\nint main() {\n    // Inicializar LEDS como salidas\n    gpio_init(LED_RO); gpio_set_dir(LED_RO, 1);\n    gpio_init(LED_AZ); gpio_set_dir(LED_AZ, 1);\n    gpio_init(LED_VE); gpio_set_dir(LED_VE, 1);\n    gpio_init(LED_AM); gpio_set_dir(LED_AM, 1);\n\n    // Inicializar botones como entradas\n    gpio_init(Boton_RO); gpio_set_dir(Boton_RO, 0);\n    gpio_init(Boton_AZ); gpio_set_dir(Boton_AZ, 0);\n    gpio_init(Boton_VE); gpio_set_dir(Boton_VE, 0);\n    gpio_init(Boton_AM); gpio_set_dir(Boton_AM, 0);\n\n    //Mientras que ninguno de los botones este presionado, todos los leds van a estar apagados\n    while (gpio_get(Boton_RO) == 0 &amp;&amp; gpio_get(Boton_AZ) == 0 &amp;&amp; gpio_get(Boton_VE) == 0 &amp;&amp; gpio_get(Boton_AM) == 0) {\n        gpio_put(LED_RO, 0);\n        gpio_put(LED_AZ, 0);\n        gpio_put(LED_VE, 0);\n        gpio_put(LED_AM, 0);\n        sleep_ms(1);\n    }\n\n    //La semilla para los numeros aleatorios usando el tiempo para que nuestra secuencia sea diferente cada vez\n    srand(time_us_32());\n\n    // Se repite hasta que lleguemos a las 15 rondas    \n    for (int i = 0; i &lt; Rondas; i++) {\n\n        int led_on = rand() % 4;  // Para que nos de un numero del 0 al 3\n\n        if (led_on == 0) Secuencia[i] = LED_RO;  // Se guarda en el array la secuencia, si es 0 es rojo\n\n        else if (led_on == 1) Secuencia[i] = LED_AZ;\n\n        else if (led_on == 2) Secuencia[i] = LED_VE;\n\n        else if (led_on == 3) Secuencia[i] = LED_AM;\n    }\n\n    bool fallo = false; // Variable para controlar si el jugador ha fallado, false si no ha fallado, true si ha fallado\n\n    // Juego principal se repite hasta que se acaben las rondas o haya un fallo\n    for (int ronda = 0; ronda &lt; Rondas &amp;&amp; !fallo; ronda++) {\n        // Se muestra la secuencia, segun lo que se tenga guardado en el array\n        for (int i = 0; i &lt;= ronda; i++) {\n            int led = Secuencia[i];  // Encender el led correspondiente\n            gpio_put(led, 1); sleep_ms(500);\n            gpio_put(led, 0); sleep_ms(500);\n        }\n\n        // El jugador debe repetir la secuencia, se enciende el led que ha pulsado\n        for (int i = 0; i &lt;= ronda; i++) {\n            int pulsado = leer_boton();\n            gpio_put(pulsado, 1); sleep_ms(200);\n            gpio_put(pulsado, 0); sleep_ms(100);\n\n            // Comprobar si ha fallado la secuencia\n            if (pulsado != Secuencia[i]) { //si el led pulsado no es igual al de la secuencia, ha fallado, por lo que se cambia el valor de fallo a true y se sale del bucle\n                fallo = true;\n                break;\n            }\n        }\n        sleep_ms(800);\n    }\n\n    // Si hubo fallo, parpadear todos los leds 4 veces\n    if (fallo) {\n      for (int k = 0; k &lt; 4; k++) {\n        gpio_put(LED_RO, 1); gpio_put(LED_AZ, 1);\n        gpio_put(LED_VE, 1); gpio_put(LED_AM, 1);\n        sleep_ms(200);\n        gpio_put(LED_RO, 0); gpio_put(LED_AZ, 0);\n        gpio_put(LED_VE, 0); gpio_put(LED_AM, 0);\n        sleep_ms(200);\n      }\n    }\n\n    if (!fallo) {\n       for (int j = 0; j &lt; 5; j++) {\n        gpio_put(LED_RO, 1); sleep_ms(100);\n        gpio_put(LED_AZ, 1); sleep_ms(100);\n        gpio_put(LED_VE, 1); sleep_ms(100);\n        gpio_put(LED_AM, 1); sleep_ms(100);\n        gpio_put(LED_RO, 0); sleep_ms(100);\n        gpio_put(LED_AZ, 0); sleep_ms(100);\n        gpio_put(LED_VE, 0); sleep_ms(100);\n        gpio_put(LED_AM, 0); sleep_ms(100);\n       }\n    }\n\n    // Apagar todo\n    gpio_put(LED_RO, 0);\n    gpio_put(LED_AZ, 0);\n    gpio_put(LED_VE, 0);\n    gpio_put(LED_AM, 0);\n\n    while (true){\n      tight_loop_contents(); // Mantener el programa corriendo\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Examen_1/#video-del-funcionamiento-simon-dice","title":"Video del Funcionamiento: Sim\u00f3n Dice","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C1/","title":"Tarea 1,1","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C1/#comparacion-de-microcontroladores","title":"Comparaci\u00f3n de Microcontroladores","text":"<p>Como primera actividad se quiere comparar cuatro microcontroladores para la realizaci\u00f3n de un proyecto mecatr\u00f3nico a elegir tomando en cuenta las siguientes caracter\u00edsticas:</p> <ul> <li>Perifericos</li> <li>Memoria</li> <li>Ecosistema</li> <li>Costos</li> <li>Arquitectura</li> <li>Velocidad de trabajo</li> </ul>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C1/#proyecto-a-tener-en-cuenta","title":"Proyecto a Tener en Cuenta","text":"<p><code>AirMouse</code></p> <p>Se tom\u00f3 como referencia un proyecto ya realizado, porque es m\u00e1s sencillo conocer las necesidades que el proyecto le pide al microcontrolador. Como son unos perifericos adecuados y principalmente una velocidad de trabajo excepcional.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C1/#tabla-comparativa","title":"Tabla Comparativa","text":"<p>Para elegir los microcontroladores a comparar, se tom\u00f3 en cuenta la capacidad de conexi\u00f3n por medio de Wifi o Bluetooth y un tama\u00f1o compacto.</p> Microcontrolador Perif\u00e9ricos Memoria Ecosistema Costos Arquitectura Velocidad de trabajo Seeed XIAO ESP32-C3 WiFi, BLE 5.0, UART, I2C, SPI, ADC, PWM 400 KB SRAM + 4 MB Flash Arduino, ESP-IDF, MicroPython 180-300 MXN RISC-V 32-bit 160 MHz Arduino Nano RP2040 Connect WiFi, BLE, IMU integrado, UART, I2C, SPI, ADC, PWM 264 KB SRAM + 16 MB Flash Arduino + Pico SDK, MicroPython 530-750 MXN Dual-core ARM Cortex-M0+ 133 MHz Adafruit Feather nRF52840 BLE 5.0, USB nativo, UART, I2C, SPI, ADC, PWM 256 KB RAM + 1 MB Flash Arduino, CircuitPython, Zephyr 720-950 MXN ARM Cortex-M4F 32-bit 64 MHz Seeed XIAO ESP32-S3 WiFi, BLE 5.0, USB-C nativo, UART, I2C, SPI, ADC, PWM 512 KB SRAM + 8 MB PSRAM + 8 MB Flash (modelo con PSRAM) Arduino, ESP-IDF, MicroPython 210-330 MXN Xtensa LX7 dual-core 32-bit 240 MHz <p>1.- Seeed XIAO ESP32-S3: Considero que este microcontrolador es la mejor opci\u00f3n por ser el controlador con mayor potencia, buen tama\u00f1o de memoria, un tama\u00f1o compacto, y un costo considerablemente bajo a pesar de no ser el m\u00e1s barato, teniendo capacidad de conexi\u00f3n via BLE y Wifi.</p> <p>2.- Seeed XIAO ESP32-C3: Es una buena opci\u00f3n porque es muy barato y peque\u00f1o, con WiFi y BLE integrados. Aunque no tiene tanta potencia como el S3, cumple bien para un prototipo funcional.</p> <p>3.- Arduino Nano RP2040 Connect: Es completo porque ya trae WiFi, BLE y un sensor IMU integrado. Sin embargo, es el m\u00e1s caro y m\u00e1s grande de todos, lo que lo hace menos c\u00f3modo para el guante.</p> <p>4.-Adafruit Feather nRF52840 Express: Su ventaja es que tiene un buen Bluetooth y consume poca energ\u00eda, pero es lento comparado con los dem\u00e1s y m\u00e1s caro de lo que deber\u00eda, por eso queda en \u00faltimo lugar.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/","title":"Tarea 1,2","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#outputs-basicos","title":"Outputs Basicos","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#contador-en-binario-del-0-al-15","title":"Contador en Binario del 0 al 15","text":"<p>En cuatro leds debe mostrarse cada segundo la representacion binaria del 0 al 15.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n\nint main() {\n    // 1) M\u00e1scara con varios pines\n    const uint32_t MASK = (1u&lt;&lt;LED_1) | (1u&lt;&lt;LED_2) | (1u&lt;&lt;LED_3) | (1u&lt;&lt;LED_4);\n\n    // 2) Asegura funci\u00f3n SIO en cada pin (necesario una sola vez)\n    gpio_init(LED_1);\n    gpio_init(LED_2);\n    gpio_init(LED_3);\n    gpio_init(LED_4);\n\n    // 3) Direcci\u00f3n: salida (OE=1) para TODOS los pines con UNA sola instrucci\u00f3n\n    sio_hw-&gt;gpio_oe_set = MASK;\n\n    while (true)\n    {\n        for (int i = 0; i &lt; 16; i++)\n        {\n            sio_hw-&gt;gpio_clr = MASK;\n\n            sio_hw-&gt;gpio_set = (i &lt;&lt; LED_1); \n\n            sleep_ms(300);\n\n        }\n\n    }\n\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#video-del-funcionamiento-conteo-binario","title":"Video del Funcionamiento: Conteo Binario","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#barrido-de-leds","title":"Barrido de LEDs","text":"<p>Correr un \u201c1\u201d por cuatro LEDs P0..P3 y regresar.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n\nint main() {\n    // M\u00e1scara de pines\n    const uint32_t MASK = (1u&lt;&lt;LED_1) | (1u&lt;&lt;LED_2) | (1u&lt;&lt;LED_3) | (1u&lt;&lt;LED_4);\n\n    // Inicializaci\u00f3n de pines\n    gpio_init(LED_1);\n    gpio_init(LED_2);\n    gpio_init(LED_3);\n    gpio_init(LED_4);\n\n    // Configurarlos como salida\n    sio_hw-&gt;gpio_oe_set = MASK;\n\n    int led_on = 0;\n    int direc = 1;\n\n    while (true) {\n\n        sio_hw-&gt;gpio_clr = MASK;\n\n        sio_hw-&gt;gpio_set = (1u &lt;&lt; led_on);\n\n        sleep_ms(200);\n\n        led_on += direc;\n\n        if (led_on == 3) direc = -1;\n        else if (led_on == 0) direc = 1;\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#video-del-funcionamiento-ping-pong","title":"Video del Funcionamiento: Ping Pong","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#secuencia-en-codigo-grey","title":"Secuencia en C\u00f3digo Grey","text":"<p>Representar la secuencia de Grey con 4 LEDs.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define PIN_A 0\n#define PIN_B 1\n#define PIN_C 2\n#define PIN_D 3\n\nint main() {\n\n    // 2) Asegura funci\u00f3n SIO en cada pin (necesario una sola vez)\n    gpio_init(0);\n    gpio_init(1);\n    gpio_init(2);\n    gpio_init(3);\n    // 3) Direcci\u00f3n: salida (OE=1) para TODOS los pines con UNA sola instrucci\u00f3n\n\n    uint32_t cont=0;\n\n\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_A);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_B);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_C);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_D);\n\n    while (true) {\n\n        uint32_t sec = cont ^ (cont &gt;&gt; 1);\n\n        if (sec&amp;0x1){\n            gpio_put(PIN_A,1);\n        }\n\n        else{\n            gpio_put(PIN_A,0);\n        }\n\n        if (sec&amp;0x2){\n            gpio_put(PIN_B,1);\n        }\n\n        else {\n            gpio_put(PIN_B,0);\n        }\n\n        if (sec&amp;0x4){\n            gpio_put(PIN_C,1);  \n        }\n\n        else{\n            gpio_put(PIN_C,0);\n        }\n\n        if (sec&amp;0x8){\n            gpio_put(PIN_D,1);      \n        }\n\n        else{\n            gpio_put(PIN_D,0);\n        }\n\n        cont++;\n\n        sleep_ms(500);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C2/#video-del-funcionamiento-patron-gray","title":"Video del Funcionamiento: Patr\u00f3n Gray","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/","title":"Tarea 1,3","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#imputs","title":"Imputs","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#compuertas-logicas-and-or-y-xor","title":"Compuertas L\u00f3gicas AND, OR y XOR","text":"<p>Compuertas b\u00e1sicas AND / OR / XOR con 2 botones qu\u00e9 debe hacer: Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#esquematco-de-conexion-compuertas-logicas","title":"Esquem\u00e1tco de conexi\u00f3n Compuertas L\u00f3gicas","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad Compuertas L\u00f3gicas.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define Boton_1 2\n#define Boton_2 4\n#define LED_1 18\n#define LED_2 17\n#define LED_3 16\n\nint main() {\n\n    gpio_init(Boton_1);\n    gpio_set_dir(Boton_1, false);\n\n    gpio_init(Boton_2);\n    gpio_set_dir(Boton_2, false);\n\n    gpio_init(LED_1);\n    gpio_set_dir(LED_1, true);\n\n    gpio_init(LED_2);\n    gpio_set_dir(LED_2, true);\n\n    gpio_init(LED_3);\n    gpio_set_dir(LED_3, true);\n\n    while (true) {\n        bool b1 = gpio_get(Boton_1);\n        bool b2 = gpio_get(Boton_2);\n\n        if (!b1 &amp;&amp; !b2) {\n            gpio_put(LED_1, 1);\n        } else {\n            gpio_put(LED_1, 0);\n        }\n\n        if (!b1 || !b2) {\n            gpio_put(LED_2, 1);\n        } else {\n            gpio_put(LED_2, 0);\n        }\n\n        if ((b1 &amp;&amp; !b2) || (!b1 &amp;&amp; b2)) {\n            gpio_put(LED_3, 1);\n        } else {\n            gpio_put(LED_3, 0);\n        }\n\n        sleep_ms(10); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#video-del-funcionamiento-compuertas-logicas","title":"Video del Funcionamiento: Compuertas L\u00f3gicas","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#ping-pong-con-botones","title":"Ping Pong con Botones","text":"<p>Selector c\u00edclico de 4 LEDs con avance/retroceso qu\u00e9 debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#esquema-de-conexion-ping-pong-con-botones","title":"Esquema de Conexi\u00f3n Ping Pong con Botones","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\nint main(void) {\n    const uint LED1 = 0;\n    const uint LED2 = 1; \n    const uint LED3 = 2;\n    const uint LED4 = 3;       \n    const uint BTN1 = 16;\n    const uint BTN2 = 17; \n\n    const uint32_t MASK = (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3) | (1u&lt;&lt;LED4);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);  \n    gpio_put_masked(MASK, 1u&lt;&lt;LED1); \n\n    gpio_init(BTN1);\n    gpio_set_dir(BTN1,0);\n    gpio_pull_up(BTN1);   \n    gpio_init(BTN2);\n    gpio_set_dir(BTN2,0);\n    gpio_pull_up(BTN2); \n\n    int pos=LED1;\n    int preb1 = 1;\n    int preb2 = 1;\n\n    while (true) {\n\n        if (gpio_get(BTN1)==0 &amp;&amp; preb1 == 1){\n            if(pos==LED4) pos=LED1;\n            else \n            pos++;\n            gpio_put_masked(MASK, (1u&lt;&lt;pos));\n        }\n\n        if (gpio_get(BTN2)==0 &amp;&amp; preb2 == 1){\n\n            if (pos==LED1)pos=LED4;\n            else \n            pos--;\n            gpio_put_masked(MASK, (1u&lt;&lt;pos));\n        }\n\n        preb1 = gpio_get(BTN1);\n        preb2 = gpio_get(BTN2);\n\n        sleep_ms (200);\n\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C3/#video-del-funcionamiento-ping-pong-con-botones","title":"Video del Funcionamiento: Ping Pong con Botones","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/","title":"Tarea 1,4","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/#interrupciones","title":"Interrupciones","text":""},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/#juego-de-ping-pong","title":"Juego de Ping Pong","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p> <p>Reglas del juego:</p> <p>1.- Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> <p>2.- Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> <p>3.- Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> <p>4.- Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> <p>5.- Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> <p>6.- Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad Juego Ping Pong.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_G1 14\n#define LED_G2 15\n\n#define Boton_1 17\n#define Boton_2 16\n\nint led_on = 2; //led con el que comienza el juego\nint direc = 0; //para la direccion +1 izquierda, -1 derecha, negativo porque al comenzar el juego comenzamos a la izquierda\n\n// 0 es no presionado, 1 es presionado\nint boton_d = 0;\nint boton_i = 0;\n\n\n\n\n//esto pasa cuando alguno de los botones se presiono\nvoid juan_perez(uint gpio, uint32_t events){\n    if (gpio == Boton_1) boton_d = 1; //para ver cual de los dos botones se presiono si es el boton1, se le asigna 1 al boton derecho\n    if (gpio == Boton_2) boton_i = 1;\n}\n\nint main() {\n\n    // Poner los leds como salida\n    gpio_init(0); gpio_set_dir(0, 1);\n    gpio_init(1); gpio_set_dir(1, 1);\n    gpio_init(2); gpio_set_dir(2, 1);\n    gpio_init(3); gpio_set_dir(3, 1);\n    gpio_init(4); gpio_set_dir(4, 1);\n\n\n    // Salida\n    gpio_init(LED_G1); gpio_set_dir(LED_G1,1);\n    gpio_init(LED_G2); gpio_set_dir(LED_G2,1);\n\n    // Entrada\n    gpio_init(Boton_1); gpio_set_dir(Boton_1,0);\n    gpio_init(Boton_2); gpio_set_dir(Boton_2,0);\n\n    // GPIO_IRQ_EDGE_RISE significa que se activa la interrupcion cuando el boton se presiona y true es para activar la interrupcion\n    gpio_set_irq_enabled_with_callback(Boton_1, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled_with_callback(Boton_2, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n\n    while (direc == 0) { // mientras que no se haya presionado ningun boton, el led de en medio esta encendido\n      gpio_put(LED_3, 1);\n      if (boton_d) {      //cuando el boton derecho se presiona la variable direc es 1, por lo que la pelota va a la izquierda        \n          direc = 1;  \n          boton_d = 0;\n      }\n      if (boton_i) {\n          direc = -1;  //cuando el boton derecho se presiona la variable direc es -1, por lo que la pelota va a la derecha\n          boton_i = 0; //resetear la variable para que no siga detectando que el boton esta presionado\n      }\n      sleep_ms(10);\n    }\n\n    while (true) {\n        // Apagar los leds para que no se queden encendidos siempre\n        for (int i = LED_1; i &lt;= LED_5; i++) gpio_put(i, 0);\n\n        // Encender el led actual\n        gpio_put(led_on, 1);\n        sleep_ms(500);\n\n\n        if (led_on == 0){   //si el led que esta encendido es el 0, quiere decir que la pelota llego al final izquierdo\n            if(boton_d){  // si se presiona el boton se cambia la direccion de la pelota a la izquierda\n                direc = 1;\n            } else {\n                gpio_put(LED_G2, 1);  // Si no se presiono, el jugador perdio y enciende el led del jugador 2\n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                sleep_ms(500);\n                gpio_put(LED_G2, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                sleep_ms(500);\n                gpio_put(LED_G2, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                led_on = 1;\n                direc = 1; // ahora la pelota va a la izquierda\n\n            }\n            boton_d = 0;  // Resetear la variable del boton derecho\n        }\n        else if (led_on == 4) {\n            if(boton_i){\n                direc = -1;\n            } else {\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                sleep_ms(500);\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                sleep_ms(500);\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                led_on = 3;\n                direc = -1;\n\n            }\n            boton_i = 0;  \n        }\n\n        // Actualizar el led actual\n        led_on += direc;\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_I/Tarea_1%2C4/#video-del-funcionamiento-juego-ping-pong","title":"Video del Funcionamiento: Juego Ping Pong","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/","title":"Tarea 2,1","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#desfase-de-tiempo-con-temporizadores","title":"Desfase de Tiempo con Temporizadores","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ul> <li>Periodo promedio y tolerancia.</li> <li>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</li> <li>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</li> </ul>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#codigo","title":"C\u00f3digo","text":"<p>Blink con timer (SDK alto nivel)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 40;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#resultado-en-el-osciloscopio","title":"Resultado en el Oscilosc\u00f3pio","text":"<p>La se\u00f1al obtenida tuvo un periodo promedio de 79.76 ms contra el periodo esperado de 80 ms dando como resultado una tolerancia del 0.3%, con un jitter aproximado de 200 \u00b5s y un voltaje de 1.54 v.</p> <p>El oscilosc\u00f3pio se configur\u00f3 con acoplamiento DC, 10 ms/div (zoom 2 ms/div), 1.0 V/div, cursores en tiempo, trigger por flanco.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</li> <li>Con el osciloscopio, mide y registra para cada modo:</li> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#codigo_1","title":"C\u00f3digo","text":"<p>Para la comparaci\u00f3n se us\u00f3 el c\u00f3digo anterior y el siguiente:</p> <p>Blink con timer de sistema (bajo nivel)</p> <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 40000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#resultado-en-el-osciloscopio_1","title":"Resultado en el Oscilosc\u00f3pio","text":"<p>La se\u00f1al  del segundo c\u00f3digo tuvo un periodo promedio de 79.968 ms contra el periodo esperado de 80 ms dando como resultado una tolerancia del 0.04%, con un jitter aproximado de 200 \u00b5s y un voltaje de 1.54 v.</p> <p>Se us\u00f3 la misma configuraci\u00f3n en el oscilosc\u00f3pio del ejercicio anterior.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C1/#resultados-de-la-comparacion","title":"Resultados de la Comparaci\u00f3n","text":"<p>Comparando ambas se\u00f1ales de 80\u202fms de per\u00edodo ideal, la segunda se\u00f1al es m\u00e1s precisa con un per\u00edodo promedio de 79.968\u202fms con una tolerancia 0.04\u202f% frente a los 79.76\u202fms de la primera y una tolerancia 0.3\u202f%, mientras que el jitter y el voltaje son id\u00e9nticos en ambas, 200\u202f\u00b5s y 1.54\u202fV respectivamente. Esto indica que, aunque ambas son estables, la segunda ofrece una mayor exactitud temporal.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/","title":"Tarea 2,2","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#ejercicio-de-programacion-timers","title":"Ejercicio de Programaci\u00f3n Timers","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#cuatro-alarmas-cuatro-leds-a-distintas-frecuencias","title":"Cuatro Alarmas / Cuatro LEDs a Distintas Frecuencias","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p> <p>Se intento activar la cuarta alarma \u201cALARMA3\u201d pero en ning\u00fan momento esta alarma funciono, por lo cual solo se implementaron 3 alarmas. </p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#esquematico-de-conexion-leds-diferentes-frecuencias","title":"Esquem\u00e1tico de conexi\u00f3n LEDs Diferentes Frecuencias","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad LEDs a diferentes frecuencias.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0   // LED integrado\n#define LED1_PIN     1      \n#define LED2_PIN     2           // LED externo en GPIO 0\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us , next2_us;\nstatic const uint32_t INTERVALO0_US = 250000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 800000u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#video-del-funcionamiento-leds-a-distintas-frecuencias","title":"Video del Funcionamiento: LEDs a Distintas Frecuencias","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#ping-pong-con-diferentes-velocidad","title":"Ping Pong con Diferentes Velocidad","text":"<p>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#esquematico-de-conexion-ping-pong-velocidades","title":"Esquem\u00e1tico de conexi\u00f3n Ping Pong Velocidades","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad Ping Pong con distintas velocidades.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include \"pico/time.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_G1 14\n#define LED_G2 15\n\n#define Boton_Len 16\n#define Boton_Rap 17\n\n#define Boton_1 27\n#define Boton_2 26\n\nint led_on = 2; // led con el que comienza el juego\nint direc = 0; // para la direccion +1 izquierda, -1 derecha, negativo porque al comenzar el juego comenzamos a la izquierda\n\n// 0 es no presionado, 1 es presionado\nint boton_d = 0;\nint boton_i = 0;\n\nvolatile int velocidad = 450; // velocidad inicial de la pelota\nconst int velocidad_max = 150; \nconst int velocidad_min = 1050; \nconst int cambio = 150; \n\nrepeating_timer_t timer;\n\n//esto pasa cuando alguno de los botones se presiono\nvoid juan_perez(uint gpio, uint32_t events){\n    if (gpio == Boton_1) boton_d = 1;\n    if (gpio == Boton_2) boton_i = 1;\n\n    if (gpio == Boton_Len &amp;&amp; velocidad &lt;= velocidad_min) {\n        velocidad += cambio;\n        cancel_repeating_timer(&amp;timer);\n        add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer);\n    }\n    if (gpio == Boton_Rap &amp;&amp; velocidad &gt;= velocidad_max) {\n        velocidad -= cambio;\n        cancel_repeating_timer(&amp;timer);\n        add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer);\n    }\n}\n\nbool Juego_Ping_Pong(repeating_timer_t *t) {\n            // Apagar los leds para que no se queden encendidos siempre\n        for (int i = LED_1; i &lt;= LED_5; i++) gpio_put(i, 0);\n\n        // Encender el led actual\n        gpio_put(led_on, 1);\n\n        if (led_on == 0){ // si el led que esta encendido es el 0, quiere decir que la pelota llego al final izquierdo\n            if(boton_d){  // si se presiona el boton se cambia la direccion de la pelota a la izquierda\n                direc = 1;\n            } else {\n                gpio_put(LED_G2, 1); sleep_ms(500); // Si no se presiono, el jugador perdio y enciende el led del jugador 2\n                gpio_put(LED_G2, 0); sleep_ms(500);\n                gpio_put(LED_G2, 1); sleep_ms(500);\n                gpio_put(LED_G2, 0); sleep_ms(500);\n                gpio_put(LED_G2, 1); sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                led_on = 1;\n                direc = 1; // Ahora la pelota va a la izquierda\n\n            }\n            boton_d = 0;  // Resetear la variable del boton derecho\n        }\n        else if (led_on == 4) {\n            if(boton_i){\n                direc = -1;\n            } else {\n                gpio_put(LED_G1, 1); sleep_ms(500);\n                gpio_put(LED_G1, 0); sleep_ms(500);\n                gpio_put(LED_G1, 1); sleep_ms(500);\n                gpio_put(LED_G1, 0); sleep_ms(500);\n                gpio_put(LED_G1, 1); sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                led_on = 3;\n                direc = -1;\n\n            }\n            boton_i = 0;  \n        }\n\n        // Actualizar el led actual\n    led_on += direc;\n    return true; // Indica que el temporizador debe reiniciarse\n\n}\n\nint main() {\n\n    // Poner los leds como salida\n    gpio_init(0); gpio_set_dir(0, 1);\n    gpio_init(1); gpio_set_dir(1, 1);\n    gpio_init(2); gpio_set_dir(2, 1);\n    gpio_init(3); gpio_set_dir(3, 1);\n    gpio_init(4); gpio_set_dir(4, 1);\n\n\n    // Salida\n    gpio_init(LED_G1); gpio_set_dir(LED_G1,1);\n    gpio_init(LED_G2); gpio_set_dir(LED_G2,1);\n\n    // Entrada\n    gpio_init(Boton_1); gpio_set_dir(Boton_1,0); \n    gpio_init(Boton_2); gpio_set_dir(Boton_2,0);\n\n    gpio_init(Boton_Len); gpio_set_dir(Boton_Len,0);\n    gpio_init(Boton_Rap); gpio_set_dir(Boton_Rap,0);\n\n    // GPIO_IRQ_EDGE_RISE significa que se activa la interrupcion cuando el boton se presiona y true es para activar la interrupcion\n    gpio_set_irq_enabled_with_callback(Boton_1, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled(Boton_2, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(Boton_Len, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(Boton_Rap, GPIO_IRQ_EDGE_RISE, true);\n\n    while (direc == 0) { // mientras que no se haya presionado ningun boton, el led de en medio esta encendido\n      gpio_put(LED_3, 1);\n      if (boton_d) {      //cuando el boton derecho se presiona la variable direc es 1, por lo que la pelota va a la izquierda        \n          direc = 1;  \n          boton_d = 0;\n      }\n      if (boton_i) {\n          direc = -1;  //cuando el boton derecho se presiona la variable direc es -1, por lo que la pelota va a la derecha\n          boton_i = 0; //resetear la variable para que no siga detectando que el boton esta presionado\n      }\n      sleep_ms(10);\n    }\n\n    add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer); // Iniciar el temporizador con la velocidad inicial\n\n    while (true) {\n        tight_loop_contents(); // Mantiene el programa corriendo\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C2/#video-del-funcionamiento-ping-pong-con-diferentes-velocidades","title":"Video del Funcionamiento: Ping Pong con Diferentes Velocidades","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/","title":"Tarea 2,3,1","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/#control-de-duty-cycle-y-motor-dc","title":"Control de Duty Cycle y Motor DC","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> <p>Documentar:</p> <ul> <li> <p>Valores de duty usados, con el porque.</p> </li> <li> <p>Circuito</p> </li> <li> <p>Codigo</p> </li> </ul> <p>Recomendaci\u00f3n</p> <p>No olvidar que el microcontrolador no entrega suficiente potencia, se debe usar un puente H o driver de motor para conectar el motor DC.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/#valores-del-duty","title":"Valores del Duty","text":"<ul> <li> <p>Velocidad Baja: 255 Se us\u00f3 este valor como el m\u00ednimo porque el motor funciona con minimo 3v a maximo 12v siendo 3v el 25% de 12v, lo que corresponde a 255 de 1023.</p> </li> <li> <p>Velocidad Media: 511 Este valor es la mitad del valor m\u00e1ximo.</p> </li> <li> <p>Velocidad Alta: 1023 Es el valor m\u00e1ximo del Duty.</p> </li> </ul>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/#esquematico-de-conexion-control-de-motor-dc","title":"Esquem\u00e1tico de conexi\u00f3n Control de Motor DC","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad Control de Motor DC.</p> <p></p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BOTON1 16\n#define BOTON2 19\n#define MOTOR 0\n#define F_PWM_HZ 2000   // 2 kHz: fuera del rango visible\n#define TOP 1023        // 10 bits de resoluci\u00f3n\n\nint BOTON1ESTADO=0;\nint BOTON2ESTADO=0;\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(MOTOR, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(MOTOR);\n    uint chan  = pwm_gpio_to_channel(MOTOR);\n\n    // Calcular divisor\n    float f_clk = 150000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 1023);\n    pwm_set_enabled(slice, true);\n\n\n    gpio_init(BOTON1); gpio_set_dir(BOTON1,0);\n    gpio_init(BOTON2); gpio_set_dir(BOTON2,0);\n\n    int velocidades[3]={250,512,1023};\n    int velocidad_actual=0;\n\n    while (true) {\n        BOTON1ESTADO=gpio_get(BOTON1);\n        BOTON2ESTADO=gpio_get(BOTON2);\n\n        if (BOTON1ESTADO==1){\n            velocidad_actual++;\n            if (velocidad_actual&gt;2){\n                velocidad_actual=0;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        if (BOTON2ESTADO==1){\n            velocidad_actual--;\n            if (velocidad_actual&lt;0){\n                velocidad_actual=2;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C1/#video-del-funcionamiento-control-de-duty-cycle-y-motor-dc","title":"Video del Funcionamiento: Control de Duty Cycle y Motor DC","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C2/","title":"Tarea 2,3,2","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C2/#control-de-frecuencia-y-cancion-con-buzzer","title":"Control de Frecuencia y Canci\u00f3n con Buzzer","text":"<p>PUNTO EXTRA</p> <p>PUNTO EXTRA</p> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <p>Documentar:</p> <ul> <li>Tabla con notas, frecuencias y duraci\u00f3n usadas.</li> <li>Evidencia en audio o video de la melod\u00eda funcionando.</li> </ul> <p>Recomendaci\u00f3n</p> <p>La mejor frecuencia de trabajo del buzzer es t\u00edpicamente entre 532 Hz y 4 kHz y adaptar las notas a una octava que suene clara en ese rango.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C2/#tabla-con-notas-frecuencias-y-duracion-usadas","title":"Tabla con Notas, Frecuencias y Duraci\u00f3n usadas.","text":"NOTA FRECUENCIA DURACI\u00d3N ESTROFA 1 DO 560 125 DO 560 125 DO 560 125 FA 700 200 LA 880 200 ESTROFA 2 DO 560 125 DO 560 125 DO 560 125 FA 700 200 LA 880 200 ESTROFA 3 FA 700 100 FA 700 100 MI 720 100 MI 720 100 RE 600 100 RE 600 100 DO 560 200 ESTROFA 4 DO 560 125 DO 560 125 DO 560 125 MI 720 125 SOL 800 125 ESTROFA 5 DO 560 125 DO 560 125 DO 560 125 MI 720 125 SOL 800 125 ESTROFA 6 SOL 800 125 LA 880 125 SOL 800 125 FA 700 125 MI 720 125 RE 600 125 DO 560 125"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define LED_PIN 0\n#define TOP 4096\n#define MI  660.0f\n#define SOL 800.0f\n#define DO 560.0f\n#define SI  1000.0f\n#define RE  600.0f\n#define LA  880.0f\n#define FA  700.0f\n#define DO2  525.0f \n#define RE2  1200.0f\n#define NADA 1.0f\n\n#define delay_nota0 100\n#define delay_nota1 125\n#define delay_nota2 200\n#define delay_nota3 350\n#define silencio 100\n#define silencio1 125\n#define silencio3 500\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 2000);\n    pwm_set_enabled(slice, true);\n\n    float f_clk = 150000000.0f;\n    float div;\n\n    while (true) {\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000);\n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000);\n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);\n\n    //TERCERA ESTROFA\n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (DO2 * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n    //CUARTO ESTROFA\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n        //QUINTO ESTROFA\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n        //SEXTO ESTROFA\n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(4000); \n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C2/#cancion-la-cucaracha-en-buzzer","title":"Canci\u00f3n La Cucaracha en Buzzer","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C3/","title":"Tarea 2,3,3","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C3/#generacion-de-senale-senoidal-de-60-hz-con-pwm-con-filtro-rc","title":"Generaci\u00f3n de Se\u00f1ale Senoidal de 60 Hz con PWM con Filtro RC","text":"<p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> <p>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</p> <p>Explicaci\u00f3n de la frecuencia de corte:</p> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> <p>La frecuencia de corte (fcf_cfc) es el punto donde el filtro empieza a atenuar las se\u00f1ales.</p> <p>Matem\u00e1ticamente:</p> <p>En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p> <p>Valores recomendados para un fc\u2248100Hz</p> <ul> <li> <p>Opci\u00f3n 1: R=2.2\u2009k\u03a9R C=0.68\u2009\u03bcF fc\u2248106Hz.</p> </li> <li> <p>Opci\u00f3n 2: R=1.6\u2009k\u03a9R, C=1\u2009\u03bcF  fc\u2248100Hz</p> </li> </ul> <p>Conexion:</p> <ol> <li> <p>La salida de PWM entra en la resistencia.</p> </li> <li> <p>Despu\u00e9s de la resistencia, conectar el capacitor a tierra.</p> </li> <li> <p>El punto entre resistencia y capacitor es la salida filtrada, que se conecta al osciloscopio.</p> </li> </ol>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C3/#codigo","title":"C\u00f3digo","text":"<pre><code>// pwm_led.c \u2014 Atenuar LED con PWM en GPIO 2\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define LED_PIN 0\n#define F_PWM_HZ 100   // 2 kHz: fuera del rango visible\n#define TOP 255        // 10 bits de resoluci\u00f3n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    // Calcular divisor\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // Fade\n    int level = 0, step = 35, dir = +step;\n\n\n    while (true) {\n        pwm_set_chan_level(slice, chan, level);\n\n        level += dir * step;\n        if (level &gt;= TOP) {\n            level = TOP;\n            dir = -1;\n        } else if (level &lt;= 0) {\n            level = 0;\n            dir = 1;\n        }\n\n        sleep_ms(1);\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C3/#senal-sin-filtro-rc","title":"Se\u00f1al sin Filtro RC","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C3%2C3/#senal-con-filtro-rc","title":"Se\u00f1al con Filtro RC","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/","title":"Tarea 2,4","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#comunicacion-uart","title":"Comunicaci\u00f3n UART","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#boton-con-instruccion-led-on-led-off","title":"Bot\u00f3n con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite encender y apagar un LED mediante un bot\u00f3n f\u00edsico. Cada vez que se presiona el bot\u00f3n, el LED cambia de estado: si est\u00e1 apagado se enciende (\u201cLED ON\u201d) y si est\u00e1 encendido se apaga (\u201cLED OFF\u201d).</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#codigo-recepcion","title":"C\u00f3digo Recepci\u00f3n","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    char buffer[10];\n    int i = 0;\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n\n            if (c == '\\n') {\n                buffer[i] = '\\0';  \n\n                if (strcmp(buffer, \"LED ON\") == 0) {\n                    gpio_put(LED_PIN, 1);\n                    printf(\" LED ON\\n\");\n                } else if (strcmp(buffer, \"LED OFF\") == 0) {\n                    gpio_put(LED_PIN, 0);\n                    printf(\" LED OFF\\n\");\n                }\n\n                i = 0;\n            } else if (i &lt; sizeof(buffer) - 1) {\n                buffer[i++] = c;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#codigo-envio","title":"C\u00f3digo Env\u00edo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define LED_PIN 14        \n#define BUTTON_PIN 3      \n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    bool estado = false;\n    bool presionado_anterior = false;\n\n    while (true) {\n        bool presionado = !gpio_get(BUTTON_PIN);  \n\n        if (presionado &amp;&amp; !presionado_anterior) {\n            estado = !estado;  \n\n            if (estado) {\n                gpio_put(LED_PIN, 1);\n                uart_puts(UART_ID, \"LED ON\\n\");\n                printf(\"LED ON\\n\");\n            } else {\n                gpio_put(LED_PIN, 0);\n                uart_puts(UART_ID, \"LED OFF\\n\");\n                printf(\"LED OFF\\n\");\n            }\n\n            sleep_ms(200);\n        }\n\n        presionado_anterior = presionado;\n    }\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#video","title":"Video","text":""},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#terminal-con-instruccion-led-on-led-off","title":"Terminal con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite controlar el encendido y apagado de un LED desde el monitor serial. El usuario escribe los comandos \u201cLED ON\u201d o \u201cLED OFF\u201d en la terminal, y el microcontrolador ejecuta la acci\u00f3n correspondiente.</p>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#codigo-recepcion_1","title":"C\u00f3digo Recepci\u00f3n","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#codigo-envio_1","title":"C\u00f3digo Env\u00edo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    sleep_ms(2000);\n    printf(\"\\nConexi\u00f3n lista. Escribe 'on;' o 'off;'.\\n\");\n\n    while (true) {\n        int ch_int = getchar_timeout_us(10000);\n\n        if (ch_int == PICO_ERROR_TIMEOUT) {\n            continue;\n        }\n\n        char ch = (char)ch_int;\n\n        if (ch == '\\r' || ch == '\\n') {\n            continue;\n        }\n\n        mensaje += ch;\n\n        if (ch == ';') {\n            string comando = mensaje.substr(0, mensaje.length() - 1);\n\n            if (comando == \"on\" || comando == \"off\") {\n                printf(\"Instrucci\u00f3n: %s\\n\", mensaje.c_str());\n                uart_puts(UART_ID, mensaje.c_str());\n            } else {\n                printf(\"Instrucci\u00f3n inv\u00e1lida: '%s'\\n\", comando.c_str());\n            }\n\n            mensaje = \"\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas_Embebidos_I/Corte_II/Tarea_2%2C4/#video_1","title":"Video","text":""},{"location":"Uso_de_PG/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Uso_de_PG/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Uso_de_PG/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Uso_de_PG/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Uso_de_PG/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Uso_de_PG/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Uso_de_PG/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Uso_de_PG/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Uso_de_PG/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Uso_de_PG/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Uso_de_PG/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Uso_de_PG/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Uso_de_PG/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Uso_de_PG/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Uso_de_PG/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Uso_de_PG/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Uso_de_PG/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.shdkvhdsk</p>"},{"location":"Uso_de_PG/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Uso_de_PG/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Uso_de_PG/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Uso_de_PG/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Uso_de_PG/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Uso_de_PG/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Uso_de_PG/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}